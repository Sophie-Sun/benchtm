% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_power.R
\name{calc_power}
\alias{calc_power}
\title{Power calculation to detect overall treatment effect and interaction effect}
\usage{
calc_power(
  b,
  scal,
  prog_vals,
  trt,
  pred_vals,
  alpha,
  type,
  sign_better,
  sigma_error
)
}
\arguments{
\item{b}{Vector of length 2: Coefficient for treatment indicator
and predictive term in the true model}

\item{scal}{Scaling parameter for the covariance matrix}

\item{prog_vals}{Vector of main effects (one value per patient)}

\item{trt}{Vector of treatment indicators}

\item{pred_vals}{Vector of predictive effects (one value per
patient)}

\item{alpha}{Vector of length 2, specifying the desired type 1
error for the overall and the interaction test. The overall test
is performed as a one-sided test (see also argument
sign_better). The interaction test is performed as a two-sided
test.}

\item{type}{type of data "continuous", "binary", "count" and
"survival" are allowed here, but calculations are only
implemented for "continuous" and "binary".}

\item{sign_better}{1 if larger response is better, -1 is smaller
response is better (used in power calculation for the overall
test only)}

\item{sigma_error}{Residual variance assumed for type = "continuous"}
}
\value{
Vector of two power values
}
\description{
Calculate power for overall treatment effect (not utilizing any
covariates) and the power of the interaction test (under the true
model, which is Y=f_prog+(b0+b1*f_pred)*trt). The calculation is
performed conditional on a given data set of covariates (prognostic
effects specified via prog_vals; predictive effects specified via
pred_vals) and a treatment indicator. It is assumed that the
treatment indicator is independent of the columns in X). The power
of the overall test and the interaction test will depend on the
actual observed covariates. To make calculations independent of the
actual observed covariates (to focus on the super-population) it is
suggested to simulate a large number of covariates (e.g. 100 times
larger sample size than one would be interested in), based on this
one can determine the covariance matrix of the estimates. To obtain
a covariance matrix estimate for the sample size one is interested
in one can then scale up the covariance matrix estimate (e.g. by
100-fold in the example above).
}
\examples{
###### generate a matrix of covariates
scal <- 100
X <- generate_X_dist(n=500*scal, p=30, rho=0.5)
trt <- generate_trt(n=500*scal, p_trt = 0.5)
prog <- "0.5*((X1=='Y')+X11)"
pred <- "X11>0.5"
pred_vals <- with(X, eval(parse(text = pred)))
prog_vals <- with(X, eval(parse(text = prog)))
alpha <- c(0.025,0.1)
calc_power(b=c(0,0), scal, prog_vals, trt, pred_vals, alpha,
           type="continuous", sigma_error=1, sign_better=1)
calc_power(b=c(0.2,0.3), scal, prog_vals, trt, pred_vals, alpha,
           type="continuous", sigma_error=1, sign_better=1)
calc_power(b=c(0,0), scal, prog_vals, trt, pred_vals, alpha,
           type="binary", sign_better=1)
calc_power(b=c(0.5,0.8), scal, prog_vals, trt, pred_vals, alpha,
           type="binary", sign_better=1)
}
